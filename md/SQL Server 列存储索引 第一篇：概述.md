\> 本文由 \[简悦 SimpRead\](http://ksria.com/simpread/) 转码， 原文地址 \[www.cnblogs.com\](https://www.cnblogs.com/ljhdo/p/13889942.html)

在 2017 年，我第一次接触列存储索引（ColumnStore），数据库环境是 SQL Server 2012，微软第一次在 SQL Server 2012 中推广列存储索引，到现在的 SQL Server 2017 环境，列存储索引发生了很大的变化，举个例子，当时的列存储索引是不能更新的，只能先把删除列存储索引，再更新数据，最后重建列存储索引。虽然使用十分不方便，但是查询性能真的令人惊艳。

现在数据库环境升级到了 SQL Server 2017，要重新认识列存储索引了。列存储索引是数据仓库中用于查询和存储大型事实表和维度表的标准实现，它使用基于列的数据存储格式和高于传统行存储格式 10 倍的压缩率，不仅使得列存储索引得查询性能比传统的面向行的存储高出约 10 倍，而且存储空间得消耗会减少约 10 倍。

一，列存储索引的基本概念
------------

列存储索引的实现机制，从顶层设计来说，是先把数据分组，在每一个分组中，再按照列来存储数据。

**1，列存储、行存储和增量存储的概念**

行存储（Row Store）：是传统的数据存储格式，以行格式来实现。在物理存储上，数据按照行来存储，一行包含所有的数据列。

列存储 (Column Store)：是以列格式来存储数据，各个列单独存储。列存储索引实际上以列存储格式来存储 “大多数” 数据，部分数据以行存储格式存储。在列存储格式中，数据以列为单位来压缩和解压缩，在一行数据中，对于需要的数据列进行解压缩和查询，而对于不需要的列，可以忽略，这样可以快速扫描大型表的整个列。

增量存储（Delta Store）：是以行存储格式存储的聚集索引，列存储索引会把一些数据存储为行存储格式，这些数据被称为 deltastore（ 增量存储区），它用于存储在一次插入操作中因为数量太少而无法压缩到列存储中的行，每个增量行组都是通过行版本的聚集 B-Tree 索引来实现的。

**2，行组（Rowgroup）**

行组是基础表中的一组数据行，这些数据行作为列存储索引的一个片段，列存储索引对该行组中的所有数据行做为一个整体进行压缩和查询。为了获得高性能和高压缩率，columnstore 索引把表切成行组，然后对每个行组中的各个数据列进行压缩。行组中的行数必须足够大，阈值是 100 万行，以提高压缩率，压缩之后的数据最终以列存储格式进行存储。

**3，列段（column segment）**

列段是行组中的每一列构成的数据，对于每一个行组，每一列都有一个列段；每一个列段都压缩到一起，存储到硬盘上。

![](https://img2020.cnblogs.com/blog/628084/202010/628084-20201028160108295-446708659.png)

二，列存储索引架构概述
-----------

聚集列存储索引是整个数据表的物理存储，为了减少列段的碎片并提高性能，columnstore 索引可能会将一些数据临时存储到一个称为 deltastore 的聚集索引中。

deltastore 是一个以 RowStore 格式存储的聚集索引，存储的数据分为两部分：一部分是新增的数据，另一部分是删除的数据。

*   对于新增的数据，该数据逻辑上存在于表中，但是，实际上，并不在列存储中，而是以 rowstore 格式存储在 deltastore 中。
*   对于被删除的数据，逻辑上被标记为删除，但是，实际上，并没有从列存储中删除，也就是说物理上没有删除，deltastore 存储的是被删除的数据行的 ID 列表。

deltastore 用于进行增量存储，该操作在后台进行，对程序员是透明的。SQL Server 基于性能的考虑，不会因为删除或更新少数几行数据，而去更新 columnstore，但是会实时更新 deltastore。为了返回正确的查询结果，聚集的列存储索引将列存储和 deltastore 的查询结果组合在一起，即把 deltastore 新增的行添加到结果集中，把 deltastore 中删除的行从结果集中删除，从而得到一个正确的结果。

![](https://img2020.cnblogs.com/blog/628084/202010/628084-20201028160330881-1109693114.png)

**1，增量行组（Delta Rowgroup）**

增量行组是仅与列存储索引一起使用的聚集 B 树索引，它存储数据行，直到行数量达到阈值（1,048,576 行），然后把数据移入列存储中，从而提高了列存储的压缩和性能。

当增量行组达到最大行数时，它将从 “打开” 状态转换为 “关闭” 状态。一个名为元组移动器（tuple-mover）的后台进程会定时检查封闭行组。如果该进程找到一个封闭的行组，那么它将压缩增量行组，并将其作为 COMPRESSED 行组存储到列存储中。

在压缩增量行组后，现有的增量行组将转换为 TOMBSTONE 状态，然后在无引用的情况下由元组移动器删除。

**2，增量存储（deltastore）**

列存储索引的每个行组都可以具有一个增量行组，所有的增量行组统称为增量存储。

在大批量加载数据的期间，大多数行直接进入列存储，而无需通过增量存储。在批量加载结束时，或者执行 INSERt 操作时，由于插入行的数量太少，无法满足列存储的最小大小（102,400 行），这些少量的数据行将进入增量存储，而不是列存储。 对于行数少于 102,400 的小型批量负载，所有行均直接进入 deltastore。

**3，非聚集列存储索引**

非集群列存储索引和集群列存储索引的功能相同，区别在于，非聚集索引是在行存储表上创建的辅助索引，而聚集列存储索引是整个表的主存储。非聚集索引包含基础表中部分或全部行和列的副本，索引被定义为表的一列或多列，并具有过滤行的可选条件。

三，列存储索引的更新
----------

加载（load）或插入（insert）的少量数据会直接进入 deltastore，而不会进入到 columnstore 中。只有当 deltastore 中的数据行超过 102,400 行时，后台进程 tuple-mover 才会把数据压缩、进而更新到 columnstore 中。

**1，少量的数据加载和插入会直接进入 deltastore**

列存储索引不是实时更新的，它通过缓冲区 deltastore 来临时存储数据，这样做的目的是避免 columnstore 的频繁更新，以提高性能。首先，只有当数据的更新数量超过阈值 102,400 行时，才会触发列存储索引的更新。

列存储索引一次将至少 102,400 行压缩到列存储索引中，从而提高了列存储的压缩率和查询性能。要以批量方式压缩数据行，columnstore 索引会累积少量加载（bulk）和插入（insert），并把数据插入到 deltastore 中。增量存储操作在后台进行，为了返回正确的查询结果，聚集列存储索引将列存储和增量存储中的查询结果组合在一起。

当行到达时，它们会进入增量存储区：

*   插入 INSERT INTO ... VALUES 语句。
*   批量加载结束时，它们的数量少于 102,400 行。
*   更新，每次更新都实现为删除和插入。

增量存储区还存储已删除行的 ID 列表，这些行已被标记为已删除但尚未从列存储中实际删除。

**2，把 deltastore 中数据更新到 columnstore 中**

每一个 delta rowgroup 最多存储 1,048,576 行，当 delta rowgroup 存储的数据行达到该阈值时，delta rowgroup 的状态由 OPEN 转换为 CLOSED，一个名为元组移动器（tuple-mover）的后台进程检查封闭行组。如果该进程找到一个封闭的行组，则将压缩该行组并把其存储到列存储中。压缩增量行组后，现有的增量行组将转换为 TOMBSTONE 状态，随后在无引用的情况下由元组移动器删除，并将新的压缩行组标记为 COMPRESSED 状态。

您可以使用 ALTER INDEX 重建或重新组织索引，以将增量行组强制进入列存储。请注意，如果在压缩过程中存在内存压力，则列存储索引可能会减少压缩的行组中的行数。

四，执行模式
------

SQL Server 数据库引擎使用两种不同的处理模式来处理 Transact-SQL 语句：

*   行模式执行（Row mode execution）
*   批模式执行（Batch mode execution）

这两个执行模式，分别用于查询行存储数据和列存储数据，适用于不同的查询类型，各有自己的优势和劣势。

**1，行模式执行**

行模式执行是与传统数据表一起使用的查询处理模式，其中数据以行格式存储。SQL Server 引擎读取所需行或索引的所有列，SQL Server 从读取的每一行中，检索 SELECT 语句，JOIN 谓词或筛选器谓词所引用的结果集所需的列。这种执行模式，会把所需行的所有列都读取出来，即使有些列是不需要的，这种执行模式特别对于查询少量数据特别有效，适用于少量数据的值查找（seek）。

**2，批模式执行**

批处理模式执行用于处理列存储的数据，同时处理多行，因此称为批处理。批处理中的每一列都作为矢量存储在单独的内存区域中，批处理模式还使用针对多核 CPU 优化的算法，并提高了现代硬件上的内存吞吐量。

批处理模式执行与列存储存储格式紧密集成并进行了优化，批处理模式在可能的情况下对压缩数据进行操作，不需要对数据进行解压缩就可以处理数据，这与行处理模式是截然不同的，相比行处理模式必须解压数据才能对数据进行处理，批处理模式能够获得更好的并行性和更快的查询性能。

当以批处理方式执行查询并访问列存储索引中的数据时，SQL Server 引擎会在列段中同时读取多行，但是 SQL Server 仅读取结果所需的列，这些列由 SELECT 语句，JOIN 谓词或过滤器谓词引用，对于数据行中的其他列，完全不需要读取，这显著地提高查询的性能。

五，列存储索引的优势
----------

列存储索引能够实现更高的数据压缩率，通常是 10 倍于普通的数据存储，显著地降低了数据仓库的存储成本。对于数据分析，列存储索引提供的查询性能比 B-Tree 索引快一个数量级。鉴于这两个原因，列存储索引成为数据仓库中用于数据存储和数据分析的首选方案。

总体来说，对列存储索引进行查询，能够获得高效率的原因主要是：

*   列存储的值来自相同的值域或范畴，通常具有很多高度相似的值，这使得数据压缩的效率非常高。进而减少了数据的存储和读取，最小化或消除了系统的 I / O 瓶颈，并显着减少了内存占用。
*   高压缩率通过使用较小的内存占用空间来提高查询性能，由于 SQL Server 可以在内存中执行更多查询和数据操作，因此查询性能可以提高。
*   批处理执行模式在同一时刻会处理多行数据，通常将查询性能提高 2 到 4 倍。
*   查询语句通常仅从表中选择少量的几列，相比行存储，从表中读取所有列，列存储的格式减少了硬盘的总 I / O。

参考文档：

[Columnstore indexes: Overview](https://docs.microsoft.com/en-us/sql/relational-databases/indexes/columnstore-indexes-overview?view=sql-server-ver15)